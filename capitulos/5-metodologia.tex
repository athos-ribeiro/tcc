\chapter{Metodologia}\label{metodologia}

Neste capítulo pretende-se apresentar toda a metodologia utilizada durante a
pesquisa realizada, podendo ser um norte para a reprodução da mesma em trabalhos
futuros.

Inicialmente, a questão de pesquisa a ser respodida com este trabalho era a
seguinte:

\begin{center}
  \textit{Como podemos monitorar e acompanhar métricas de ameaças de
    vulnerabilidade de código fonte dentro do ciclo de desenvolvimento de
    software?
}
\end{center}

Na primeira parte do trabalho foram levantadas algumas hipóteses com relação ao
monitoramento das métricas de ameaças de vulnerabilidades de código fonte,
levando em consideração trabalhos já realizados sobre métricas de orientação a
objetos e de tamanho, como o trabalho de \citeonline{meirelles2013}. As hipóteses
foram as seguintes:

\begin{itemize}
  \item \textit{H1}: As métricas de ameaças de vulnerabilidade de código fonte
  podem ser observadas de maneira similar às métricas de \textit{design} de código
  fonte.

  \item \textit{H2}: A média dos valores das métricas de ameaças de vulnerabilidade de
  código fonte, geralmente, não é representativa para o acompanhamento das mesmas.

\end{itemize}

Ao final da primeira parte da pesquisa foram respondidas as hipóteses levantadas
inicialmente. Através da análise das métricas de ameaças de vulnerabilidade de
código fonte extraídas do projeto \textit{Linux Kernel} pode-se perceber que boa
parte dos valores das métricas eram nulos (zero), o que faz sentido, já que
espera-se que não exista ameaças de vulnerabilidades em todos os módulos do
projeto. Dessa forma, as métricas de ameaças de vulnerabilidade não se
assemelham com métricas de \textit{design} de código, pois as métricas de
\textit{design} de código não costumam ter valoração nula na maioria dos casos
devido a sua própria natureza, logo, ambas não podem ser observadas de maneira
similar, negando a hipótese \textit{H1}. Além disso, em um conjunto de valores
em que a grande maioria é zero não se pode considerar a média dos mesmos
representativa, o que nega a hipótese \textit{H2}.

Foi realizado um estudo mais qualitativo das métricas em questão, foram
analisados outros projetos, que podem ser vistos no apêndice
\ref{anex:analise_qualitativa}. Após uma análise mais detalhada dos valores
das métricas dos projetos chegou-se a um subconjunto mais frequente das mesmas,
sendo elas:

\begin{itemize}\label{principais_vuln}
  \item Referência a ponteiros nulos (CWE 476)
  \item Variáveis não inicializadas (CWE 457)
  \item Vazamento de memória (CWE 401)
\end{itemize}

Esses cenários de vulnerabilidades identificados na primeira etapa da pesquisa
serviram de insumo para a continuação da mesma, que será apresentada no decorrer
deste capítulo.

Apesar de obter algumas respostas neste início de pesquisa, percebeu-se que era
necesária uma mudança de foco, pois a negação das hipóteses iniciais tornou
inviável o seguimento do trabalho como havia sido planejado, onde pretendia-se
encontrar intervalos de valores de referência para as métricas em questão, assim
como foi feito em \citeonline{meirelles2013}.




\section{Trabalhos Relacionados}\label{metodologia:trabalhosrelacionados}

Durante a pesquisa realizada encontrou-se alguns trabalhos voltados para a
avaliação de ferramentas de análise estática de ameaças de vulnerabilidade de
código, como em \citeonline{comparision_bug_finding:2004}.

Em \citeonline{fault_detection:2006}, foi analisada a efetividade de ferramentas
de análise estática desse tipo, tendo como parâmetro os testes e o número de
falhas reportadas pelos clientes. Conclui-se que ferramentas de análise estática
são efetivas para encontrar defeitos a nível de código.

No trabalho realizado pelo \textit{National Institute of Standards and
Technology} (NIST) \cite{nist_effect_static_analysis:2007} foi feito um estudo
inicial tentando identificar se a inserção de uma ferramenta de análise estática
de vulnerabilidades de código fonte dentro do ciclo de desenvolvimento de um
software aumenta a segurança do mesmo. E a conclusão desse trabalho foi que não
necessariamente a utilização dessas ferramentas melhora a segurança do software.

Entretanto, não se encontrou nenhum trabalho similar a este, que tente definir
algumas forma para monitorar e controlar métricas de ameaças de vulnerabilidade
de código fonte dentro do ciclo de desenvolvimento de um software.




\section{Planejamento da Pesquisa}\label{metodologia:planejamentopesquisa}

Para a continuação da pesquisa foi feito um planejamento, tendo em vista os
resultados da primeira etapa e os trabalhos relacionados analisados.

Antes de apresentar o planejamento da pesquisa deve-se deixar claro o que se quer
responder com a mesma, já que como foi dito anteriormente, houve uma mudança de
foco da pesquisa. A questão de pesquisa deste trabalho é:

\begin{center}
  \textit{Existe uma função matemática que possibilite a definição de um modelo de
  predição para o monitoramento de métricas de ameaças de vulnerabilidades de
  código fonte?}
\end{center}

Tendo essa questão de pesquisa em mente o objetivo deste trabalho é encontrar
uma função matemática que viabilize o monitoramento e acompanhamento dessa nova classe de
métricas que é cada vez mais importante dentro do ciclo de desenvolvimento de um
software. E para encontrar esse meio de realizar esse monitoramente e
acompanhamento forma levantadas seguintes as hipóteses:

\begin{itemize}
  \item \textit{H3}: Os valores das métricas de ameaças de vulnerabilidade de
    código fonte se comportam como distribuições estatísticas de cauda longa, e
    não distribuições estatísticas normalizáveis.

  \item \textit{H4}: A definição de um modelo baseado em uma função polinomial
    possibilita o monitoramento e acompanhamento das métricas de ameaças de
    vulnerabilidade de código fonte.
\end{itemize}

Através de uma análise exploratória dos dados espera-se responder a hipótese
\textit{H3}, onde será possível ter uma visão geral dos dados. E através da
definição e validação de modelos estatísticos será possível responder a hipótese
\textit{H4}.

Com o intuito de responder as hipóteses levantas, foi definido um fluxo de
atividades para sistematizar esta pesquisa. A figura \ref{fig:processo}
apresentada a seguir, ilustra o processo com o fluxo de atividades que foram
desenvolvidas, a fim de uma melhor compreensão do trabalho realizado.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.9\textwidth]
      {figuras/metodologia_processo.eps}
  \caption{Processo contendo atividades executadas durante a pesquisa}
  \label{fig:processo}
\end{figure}

Detalhamento das atividades apresentadas na Figura \ref{fig:processo}:

\begin{enumerate}
  \item \textbf{Selecionar projeto}: Selecionar projeto de software livre
  representativo no contexto de segurança, para que possa ser feita a análise
  sobre o mesmo. O projeto deve ser um projeto já consolidado e com várias
  versões para que possa ser feita uma análise através do tempo.

  \item \textbf{Obter código fonte}: Obter código fonte das versões disponíveis
  do projeto selecionado, para que possa ser realizada a análise estática. A
  obtenção do código fonte deve ser feita de forma automatizada.

  \item \textbf{Selecionar ferramenta de análise estática}: Analisando os pontos
  fortes e fracos das ferramentas disponíveis, selecionar a ferramenta que
  melhor se adeque ao contexto em questão.

  \item \textbf{Realizar análise estática}: Realizar a análise estática sobre o
  código fonte obtido com a ferramenta selecionado de maneira automatizada.

  \item \textbf{Tratamento dos dados}: Ajustar o formato de saída da ferramenta
  utilizada para um arquivo CSV (\textit{Common Separated Values}) se a
  ferramenta não prover, além de tratar os dados descartando o que não for
  preciso e compondo os dados para gerar novos dados se necessário. Também deve
  ser feito de forma automatizada.

  \item \textbf{Realizar análise exploratória dos dados}: Utilizando uma
  ferramenta estatística, explorar os dados a fim de entender o comportamento do
  mesmo, para que facilite a dedução de um modelo próximo do real.

  \item \textbf{Definir e validar modelos derivados dos dados}: Encontrar
  modelos estatísticos (funções matemáticas) para monitoramento, acompanhamento e
  previsão das métricas de ameaças de vulnerabilidade de código fonte. Validar
  os modelos com dados cujo os quais não foram contruídos.

  \item \textbf{Realizar conclusões}: Comparar os modelos definidos e validados
  e indicar qual seria o melhor modelo para o monitoramento, acompanhamento e
  previsão das métricas em questão.
\end{enumerate}


\section{Teste das hipóteses}\label{metodologia:testehipoteses}

Nesta sessão será descrito como foi feito o teste das hipóteses levantadas
anteriormente. Para isso foram realizadas as atividades listadas na seção
\ref{metodologia:planejamentopesquisa}, figura \ref{fig:processo}.

O projeto selecionado para testar as hipóteses foi o \textit{Linux Kernel},
assim como o mesmo foi selecionado em \citeonline{cathedral_bazaar:1997} para se
estudar a engenharia de software. Devido o \textit{Linux Kernel} seguir um
modelo \textit{Bazaar} de desenvolvimento \cite{cathedral_bazaar:1997}, a
correção de \textit{bugs}, possíveis ameaças de vulnerabilidade, se dá de
maneira muito mais rápida, o que torna interessante a análise dessa nova classe
de métricas em um software bastante consolidado. Sendo esse o primeiro projeto a
explorar a rede de colaboração de software livre nos moldes atuais
\cite{cathedral_bazaar:1997}, tornando-se uma referência. Partiu-se do
\textit{Linux Kernel} para se estudar sobre práticas de desenvolvimento de
software e a própria engenharia de software, e agora será dado o primeiro passo
com relação a definição de um modelo estatístico que auxilie no monitoramento de
métricas de ameaças de vulnerabilidade de código fonte.

O código fonte do projeto \textit{Linux Kernel} foi obtido no espelho
(\textit{mirror}) do Github\footnote{\url{https://github.com/torvalds/linux}}
do repositório oficial Git do
projeto\footnote{\url{https://git.kernel.org/cgit/}}.  Fez-se uma cópia local
do repositório e foram utilizados alguns comandos \textit{bash} (via terminal)
para que a obtenção do código de todas as \textit{tags} disponíveis fosse feita
de uma única vez. Nesse repositório não havia as \textit{tags} de todas as
versões, pois o projeto passou a utilizar o Git\footnote{Ferramenta de controle
de versão descentralizado} apenas a partir da versão 2.6.11, entretanto, foi
possível obter o código de 391 \textit{tags} (da versão 2.6.11 até 3.9, contando
com todas as \textit{releases candidates} ou \textit{releases} intermediárias),
sendo considerado um número representativo e suficiente para a realização do
estudo.

A ferramenta de análise estática de código fonte selecionada para a realização
deste estudo foi o
\textit{Cppcheck}\footnote{\url{http://cppcheck.sourceforge.net/}}.  A parte
inicial da pesquisa se deu com a ferramenta \textit{Clang Static
Analyzer}\footnote{\url{http://clang-analyzer.llvm.org/}}(um submódulo do
compilador \textit{Clang}), esta ferramenta é bem completa e consegue capturar
bem as ameaças de vulnerabilidade de código fonte, entretanto, ela faz uma
análise inter-procedural do código, o que necessita da compilação do mesmo.
Infelizmente, o projeto \textit{Linux Kernel} ainda não suporta a sua total
compilação utilizando outro compilador a não ser o
GCC\footnote{\url{https://gcc.gnu.org/}}. Existe um projeto chamado
\textit{LLVMLinux
Project}\footnote{\url{http://llvm.linuxfoundation.org/index.php/Main_Page}} que
está tentando fazer com que o \textit{Linux Kernel} possa ser compilado com o
\textit{Clang}, mas esse trabalho ainda está em andamento. Logo, decidiu-se
abandonar o \textit{Clang Static Analyzer} e encontrar uma analisador estático
cujo qual não fosse necessária a compilação do código fonte, sendo esse o
\textit{Cppcheck}, que apesar de não realizar uma análise inter-procedural, ele
se propõe a não emitir uma grande quantidade de falsos positivos, chamada
ferramenta \textit{sound}.

Após a seleção da ferramenta a ser utilizada, extrair do código fonte as
ameaças de vulnerabilidade foi relativamente simples. O código fonte referente a
todas as \textit{tags} foi armazenado em um mesmo diretório, sendo o
\textit{Cppcheck} capaz de percorrer recursivamente o diretório a procura de
arquivos de código fonte C e C++ para realizar a análise, foi necessário apenas
executar a ferramenta nesse diretório. Foram feitas algumas configurações para a
geração de um arquivo de saída para cada uma das \textit{tags}. O arquivo de
saída de todas as análises realizadas estão disponíveis no
repositório.\footnote{\url{https://github.com/lucaskanashiro/linux-analysis/tree/master/data}}

\subsection{Descrição dos dados e Engenharia de Características}

Levando em consideração as principais ameaças de vulnerabilidades levantadas na
primeira parte da pesquisa, que podem ser vistas na lista \ref{principais_vuln},
a saída da ferramenta foi tratada a fim de filtrar por essas ameaças de
vulnerabilidades, além de criar um arquivo \textit{CSV} com esses dados. O
tratamento dos dados e geração do arquivo \textit{CSV} foram feitos através dos
scripts disponíveis no
repositório\footnote{\url{https://github.com/lucaskanashiro/linux-analysis}},
assim como o próprio arquivo \textit{CSV} gerado. A tabela \ref{tab:csv}
apresenta a estrutura do arquivo \textit{CSV} gerado.

\begin{table}[h]
\centering
\caption{Estrutura do arquivo \textit{CSV} gerado.}
\label{tab:csv}
\begin{tabular}{ccccc}
\rowcolor[HTML]{EFEFEF} 
{ Version} & { CWE476} & { CWE457} & { CWE401} & { Modules} \\
linux-vXXX    & XXX          & XXX          & XXX          & XXX          
\end{tabular}
\end{table}

A coluna "Version" contém a versão do \textit{Linux Kernel} analisada, as
colunas "CWE476", "CWE457" e "CWE401" referem-se a quantidade total de cada uma
das ameaças de vulnerabilidades em toda a versão em questão, e a coluna
"Modules" representa a quantidade total de módulos daquela versão. A seguir são
apresentados os tipos de cada um dos dados:

\begin{itemize}
  \item \textbf{Version}: Texto
  \item \textbf{CWE476}: Inteiro >= 0
  \item \textbf{CWE457}: Inteiro >= 0
  \item \textbf{CWE401}: Inteiro >= 0
  \item \textbf{Modules}: Inteiro > 0
\end{itemize}

Uma análise levando em consideração apenas esses dados não seria interessante,
já que utilizando a quantidade total absoluta de ameaças de vulnerabilidade
corre-se o risco de versões com uma maior quantidade de módulos se sobressair
em relação as outras. Pensando nisso, foi realizada uma Engenharia de
Características, onde ao final se definiu uma taxa de ameaças de
vulnerabilidades por módulo, que é facilmente calculada dividindo o total de
cada uma das ameaças de vulnerabilidade pela quantidade total de módulos. Essa
taxa claramente representa a porcentagem de vulnerabilidades por módulo se
multiplicada por 100, nesse caso a mesma deve variar entre 0 e 1. Ao final, os
dados trabalhados durante a pesquisa ficaram da forma apresentada na
tabela \ref{tab:data_frame}.

\begin{table}[h]
\centering
\caption{Estrutura de dados após Engenharia de Características.}
\label{tab:data_frame}
\resizebox{\textwidth}{!}{%
\begin{tabular}{cccccccc}
\rowcolor[HTML]{EFEFEF} 
{Version} & {CWE476} & {CWE457} & {CWE401} & {Modules} & {tax\_CWE476} & {tax\_CWE457} & {tax\_CWE401} \\
linux-vXXX    & XXX          & XXX          & XXX          & XXX           & XXX              & XXX              & XXX             
\end{tabular}
}
\end{table}

Apesar de ainda manter os dados referentes a quantidade total de ameaças de
vulnerabilidade na estrutura de dados, os mesmos não foram utilizados.

\subsection{Análise Exploratória dos Dados}

Tendo todos os dados tratados e uma estrutura de dados bem definida, iniciou-se
a fase de análise dos dados. Utilizou-se análise exploratória dos dados,
diferente das técnicas estatísticas convencionais.

O primeiro passo foi tentar entender os dados e como os mesmos se relacionam
entre si, para isso se utilizou de uma matriz de correlação, onde é dado o
índice de correlação entre a permutação de todas as variáveis em questão. Esse
índice varia entre -1 e 1, sendo próximo de 1 diretamente relacionada e próximo de
-1 inversamente relacionada. A tabela \ref{tab:correlacao} apresenta a matriz de
correlação do dados coletados, lembrando que os valores totais absolutos de
ameaças de vulnerabilidade não foram utilizados na análise, apesar de estarem
presentes na estrutura de dados trabalhada.

\begin{table}[h]
\centering
\caption{Matriz de correlação.}
\label{tab:correlacao}
\begin{tabular}{ccccl}
 & \cellcolor[HTML]{EFEFEF}{Modules} & \cellcolor[HTML]{EFEFEF}{tax\_CWE476} & \cellcolor[HTML]{EFEFEF}{tax\_CWE457} & \multicolumn{1}{c}{\cellcolor[HTML]{EFEFEF}{tax\_CWE401}} \\
\cellcolor[HTML]{EFEFEF}{Modules} & 1 & \multicolumn{1}{l}{} & \multicolumn{1}{l}{} &  \\
\cellcolor[HTML]{EFEFEF}{tax\_CWE476} & - 0.2263097 & 1 & \multicolumn{1}{l}{} &  \\
\cellcolor[HTML]{EFEFEF}{tax\_CWE457} & - 0.8493021 & 0.01902783 & 1 &  \\
\cellcolor[HTML]{EFEFEF}{tax\_CWE401} & - 0.513645 & - 0.1286109 & 0.5671033 & \multicolumn{1}{c}{1}
\end{tabular}
\end{table}

Através da matriz de correlação pode-se extrair algumas informações. Pode-se ver
que, em geral, as taxas de ameaças de vulnerabilidades são inversemante
proporcionais a quantidade de módulos. Ou seja, quanto menor a quantidade de
módulos, provavelmente um software ainda imaturo, maior a quantidade de ameaças
de vulnerabilidade, assim como um software mais maduro tende a ter um maior
número de módulos com uma menor quantidade de ameaças de vulnerabilidade de
código fonte. As ameaças de vulnerabilidade em geral não possuem correlação, a
exceção seria entre a CWE457(variáveis não inicializadas) e a CWE401(vazamento
de memória), que segundo a matriz podem se correlacionar de maneira direta. Isso
pode ser levado em consideração tendo em vista que quando se declara uma
variável e não a utiliza, existe uma boa chance da mesma cair em esquecimento e
aquela região de memória não ser mais desalocada.

Após entender um pouco mais sobre a corelação entre os dados, foi feito um
\textit{scatterplot} (figura \ref{fig:scatterplot}) de todas as taxas de ameaças
de vulnerabilidade pelo número de módulos para a melhor visualização dos dados.

\begin{figure}[h]
  \centering
  \includegraphics[width=1.0\textwidth]
      {figuras/scatterplot.eps}
      \caption{\textit{Scatterplot} das taxas de ameaças de vulnerabilidade por
      módulo pelo número total de módulos}
  \label{fig:scatterplot}
\end{figure}

As taxas como esperado são números bem pequenos, já que o número total de
ameaças de vulnerabilidade de código fonte são bem menores do que o número total
de módulos.

Analisando o \textit{scatterplot} pode-se observar que, como foi percebido com a
análise da matriz de correlação, a taxa das ameaças de vulnerabilidade por módulo
tendem a diminuir quando se aumenta o número de módulos, provavelmente o projeto
de software está crescendo e tendo um processo de desenvolvimento mais maduro.
No início, o projeto tende a crescer e aumentar a sua complexidade, aumentando
as ameaças de vulnerabilidades, depois de certo ponto o projeto amadurece e
passa a melhorar o seu processo de desenvolvimento e \textit{design} do código
fonte, e as taxas de ameaças de vulnerabilidade tendem a cair.

Como pode-se ver, a CWE401 (vazamento de mémoria) se mantém sem muitas variações
mesmo aumentando o número de módulos. Além disso ela possui valores bem abaixo
em comparação com as outras taxas, o que nos mostra que um projeto de software
em geral, independente da sua maturidade e tamanho, não consegue sobreviver se
houver várias possíveis ocorrências de vazamento de memória, se isso ocorrer,
facilmente o software pode estourar a pilha onde é alocada memória para as
variáveis do programa. Devido a maior constância nas taxas dessa ameaça de
vulnerabilidade, não foi elaborado um modelo específico para ela, já que em
geral os valores se mantém.

Tendo isso em vista, as outras duas ameaças de vulnerabilidade de código fonte
(CWE476 e CWE457) serão estudadas separadamente a fim de ao final ter um modelo
para monitoramento e predição de cada uma.
