\chapter{Estudo de Caso} \label{estudodecaso}

Como foi dito na seção \ref{cap:introducao}, o problema de como realizar o
acompanhamento de métricas de vulnerabilidade de código fonte ainda não foi bem
atacado dentro do contexto da Engenharia de Software, tendo isso em vista,
foi trabalhado um estudo de caso a fim de tentar identificar qual a melhor forma
de se acompanhar e analisar métricas de código fonte dessa natureza. O estudo
de caso realizado neste trabalho visa testar algumas hipóteses iniciais que serão apresentadas
neste mesmo capítulo, além de identificar possíveis melhorias para a continuação
do mesmo.

\section{Metodologia} \label{sec:metodologia}

A metodologia utilizada neste estudo de caso foi feita baseada no trabalho
realizado por \emph{Meirelles} (\citeyear{meirelles2013}), onde foi levantada
uma hipótese inicial e cujo objetivo é testar tal hipótese. A definição das
hipóteses iniciais levantadas será apresentada na subseção \ref{subsec:hipoteses}.

A fim de facilitar o entendimento das atividades realizadas neste estudo de
caso, será apresentado a seguir o processo que foi seguido. Através do
fluxograma \ref{fig:processo_estudo_de_caso} pode-se ver o sequenciamento das
atividades realizadas e logo a seguir, na lista \ref{desc_processo}, o
detalhamento de cada uma delas.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.9\textwidth]
      {figuras/estudo_de_caso_processo.eps}
  \caption{Processo para execução do estudo de caso}
  \label{fig:processo_estudo_de_caso}
\end{figure}

Detalhamento das atividades apresentadas no fluxograma
\ref{fig:processo_estudo_de_caso}:

\begin{enumerate}\label{desc_processo}
  \item \textbf{Selecionar projetos}: Selecionar projeto de software representativo no contexto de
    vulnerabilidades de código fonte.
  \item \textbf{Obter código fonte}: Obter código fonte do projeto selecionados. Foi utilizado o código fonte
  da última versão estável do projeto.
  \item \textbf{Identificar como construir projetos}: Identificar como construir projeto selecionado. O projeto foi contruído
    segundo as orientações da própria comunidade referente ao mesmo.
  \item \textbf{Extrair métricas}: Executar ferramenta de extração de métricas de vulnerabilidade de código
    fonte. Também foram utilizadas instruções presentes na documentação da
    ferramenta em questão.
  \item \textbf{Realizar análise estatística}: Realizar análise estatísticas sobre as métricas extraídas. Foram feitos
    tratamentos necessários das informações obtidas através da análise estática
    de código fonte, já que da maneira que foi disponibilizado pela ferramenta
    não atendia os requisitos do processo de análise estatística realizado.
  \item \textbf{Analisar resultados}: Analisar resultados gerados pela análise estatística. Essa análise foi uma atividade
    manual, analisando os gráficos e tabelas geradas pela atividade anterior um
    a um.
  \item \textbf{Realizar conclusões}: Realizar conclusões. Onde foi definido se a hipótese testada estava
    correta ou não.
\end{enumerate}

Para a realização de algumas das atividades apresentadas foram utilizadas
ferramentas para a automação das mesmas, sendo elas:

\begin{itemize}
  \item \textit{Clang Static Analyzer}, para a extração das métricas de
    vulnerabilidade de código fonte.
  \item \textit{Scripts} para adequação do formato das métricas, servindo de
    apoio a atividade de Realizar análise estatística.
  \item \textit{Scripts} para análise estatísticas, que foram elaborados no
    trabalho de \emph{Meirelles} (\citeyear{meirelles2013})
\end{itemize}

Inicialmente o intuito era utilizar a ferramenta \emph{Analizo} para a extração
das métricas de vulnerabilidade, entretanto, foram encontradas limitações na
implementação dessa \textit{feature} e por isso foi utilizada a ferramenta
\emph{Clang Static Analyzer}. A evolução dessa funcionalidade da ferramenta
\emph{Analizo} é um dos objetivos deste trabalho, como foi apresentado na seção
\ref{sec:objetivos}.

Para o entendimento completo do estudo de caso, serão apresentadas as
ferramentas utilizadas na subseção \ref{subsec:ferramentas}, iniciando pela ferramenta \emph{Analizo}, que
não foi utilizado no estudo, mas que será alvo de uma das contribuições deste
trabalho. Em seguida, serão apresentadas a ferramenta \emph{Clang Static
Analyzer}, e os \textit{Scripts} utilizados.

O teste das hipóteses, desde a coleta dos dados até a análise dos resultados, serão
apresentados na subseção \ref{subsec:teste_hipotese}. Nessa subseção será
apresentado a corretude ou não da hipótese.

\subsection{Hipóteses} \label{subsec:hipoteses}

As hipóteses iniciais levantadas para este estudo de caso, foram feitas baseadas em
formas de se acompanhar e analisar métricas de \textit{design} de código fonte
apresentada em outros trabalhos, como em \emph{Meirelles}
(\citeyear{meirelles2013}). Logo, as hipóteses são:

\begin{itemize}
  \item \textit{H1}: As métricas de vulnerabilidade de código fonte podem ser
    observadas de maneira similar as métricas de \textit{design} de código
    fonte.
  \item \textit{H2}: A média dos valores das métricas de vulnerabilidade de
    código fonte, geralmente, não é representativa para o acompanhamento das mesmas.
  \item \textit{H3}: Os valores das métricas de vulnerabilidade de código fonte
    se comportam como distribuições estatísticas de cauda longa, e não
    distribuições estatísticas normalizáveis.
\end{itemize}

Todas as hipóteses apresentadas foram levantadas devido aos resultados apresentados em
\emph{Meirelles} (\citeyear{meirelles2013}) serem satisfatórios e foram
consideradas como premissas iniciais. Sendo validadas e confirmadas as hipóteses
acima, será possível encontrar valores de referência baseado em análises
quantitativas dos valores das métricas de vulnerabilidade. 

\subsection{Ferramentas} \label{subsec:ferramentas}

Nesta seção serão apresentadas as ferramentas utilizadas neste estudo de caso.

\subsubsection{Analizo} \label{analizo}

\emph{Analizo} é um conjunto de ferramentas livre, multi-linguagem (C, C++, Java), realiza análise de código fonte, é facilmente 
extensível e disponibiliza diferentes tipos de visualização. Ele suporta a extração e cálculo de um bom número de métricas de 
código fonte, geração de gráficos de dependência e análise de evolução do software \cite{analizo}.

A seguir as funcionalidades da ferramenta \emph{Analizo} \footnote{Disponível em
\url{http://www.analizo.org/features.html}}:

\begin{itemize}
  \item Analisar código-fonte escritos em C, C ++ e Java.
  \item Extrair métricas de código-fonte.
  \item Extrair métricas de uma grande quantidade de projetos em lote (\textit{batch mode}).
  \item Extrair métricas de um repositório.
  \item Desenhar gráfico de dependências.
  \item Analisar evolução do software (analisa-se várias versões do software e uma matriz de evolução é produzida).
\end{itemize}

Será iniciado o processo de manutenção corretiva da funcionalidade de extração de métricas de vulnerabilidade de código fonte 
para as linguagens C e C++, para que melhor atenda as necessidades deste trabalho. Outra funcionalidade que ainda está em 
processo de desenvolvimento é a adição do suporte da linguagem \textit{Perl}.

A ferramenta \emph{Analizo} é facilmente extensível, desde extratores até formas de visualização. A figura \ref{archanalizo} mostra
como está implementada a arquitetura em camadas da ferramenta \cite{analizoartigo}. Existem basicamente cinco módulos, o 
\textit{Core} é o modulo responsável por atividades centrais como processamento, filtros e modelos por exemplo; 
\textit{Extractor} é o módulo que contém os extratores utilizados, atualmente existem três: \textit{Clang}, \textit{Doxyparse}
e \textit{Sloccount}; \textit{Metrics} é o módulo que contém a lógica para cálculo de todas as métricas, hoje em dia possuindo
37 (trinta e sete) métricas de módulo e 4 (quatro) métricas globais; \textit{Output} é o módulo que será dada a saída da 
ferramenta, atualmente existem opções de banco de dados e arquivo CSV; \textit{Tools} é o módulo que representa várias outras
ferramentas que podem trabalhar tanto acima do \textit{Core} quanto acima dos outros módulos.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.4\textwidth]
      {figuras/analizo.eps}
  \caption{Arquitetura da ferramenta Analizo}
  \label{archanalizo}
\end{figure}

\subsubsection{Clang} \label{clang}

\emph{Clang} é um compilador \textit{front end} para as linguagens de
programação C, C++ e \textit{Objective-C}. O \emph{Clang} faz parte
do projeto LLVM \textit{Open Source} e utiliza o mesmo como seu \textit{backend}. 

O \emph{Clang} possui algumas funcionalidades e metas disponíveis no seu respectivo
\textit{site}\footnote{Disponível em: \url{http://clang.llvm.org}}, e
algumas das principais metas são:

\begin{itemize}
  \item Rápida compilação e baixo uso de memória
  \item Diagnóstico expressivos (exemplo, apresentar erros de uma maneira fácil para o usuário)
  \item Compatibilidade com o GCC
  \item Suportar diversos clientes (exemplo, análise estática e refatoração)
  \item Código fonte base simples e de fácil entendimento ("\textit{hackable}")
\end{itemize}

Algumas dessas metas estão sendo atingidas, por exemplo, um experimento realizado por \cite{naroff2009} evidenciou o rápido
tempo de compilação do Clang em comparação com o GCC. Foi feita a compilação do \textit{PostgreSQL} em computadores com as
mesmas configuraçãoes de \textit{hardware} e o resultado obtido é expresso pela figura \ref{clang_gcc}.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.4\textwidth]
      {figuras/clang_gcc.eps}
  \caption{Análise de performance do Clang em comparação com o GCC}
  \label{clang_gcc}
\end{figure}

O \emph{Clang} vem sendo desenvolvido baseado na arquitetura do projeto LLVM, ele possui bibliotecas centrais e bibliotecas de 
aplicativos, conforme é apresentado na figura \ref{clang_arch}. No contexto desse trabalho, o foco é a biblioteca de aplicativo
\textit{Analysis}. A ideia dessa biblioteca é trazer alguns benefícios para os desenvolvedores, como o descobrimento de 
\textit{bugs} o mais cedo possível; checar sistematicamente o código fonte; achar alguns \textit{bugs} mesmo na falta de caso
de testes, no caso de trechos de código difíceis de serem testados \cite{kremenek2009}. 

A análise estática realizada pelo \emph{Clang} é inter-procedural, podendo achar inconsistências entre funções/métodos, para isso,
é necessária a compilação do código fonte, onde nessa fase será construída a AST 
\cite{kremenek2009}. Essa característica pode não ser muito atraente a primeira vista, pois para realizar a análise do código 
fonte é necessário compila-lo, entretanto, pode ser um ponto positivo tendo em vista que a todo momento que for feita 
construção do software a análise será feita, mesmo que essa questão tenha sido esquecida.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.4\textwidth]
      {figuras/clang_arch.eps}
      \caption{Arquitetura da ferramenta \emph{Clang}}
  \label{clang_arch}
\end{figure}

\subsubsection{\textit{Scripts} para análise estatística} \label{scripts}

Os \textit{scripts}\footnote{Disponível em:
\url{https://gitlab.com/paulormm/tese}} foram escritos utilizando linguagem R
\footnote{Informações em: \url{http://www.r-project.org/}} que foram
inicialmente desenvolvidos em \emph{Meirelles} (\citeyear{meirelles2013}). Foi escolhida a linguagem R
devido o seu foco e poder para a realização de análises estatísticas. Uma das
atividades desse processo de análise estatística que será realizado
por esses \textit{scripts} tentará identificar qual distribuição estatística melhor se encaixa nos dados referentes a 
determinada métrica, são utilizadas as seguintes distribuições estatísticas:

\begin{itemize}
  \item Pareto
  \item Pareto tipo 2
  \item Exponencial
  \item Gama
  \item Weibull
  \item Poison
\end{itemize}

Caso nenhuma das distribuições apresentadas consigam refletir os valores de uma determinada métrica de vulnerabilidade, os
\textit{scripts} tentarão encontrar uma distribuição estatística que melhor se adeque. Gráficos de cada distribuição serão
gerados como saída desse processo de análise estatística para melhor visualização dos dados. Como entrada teremos arquivos
CSV com os valores das métricas a serem analisadas.

Outro tipo de análise que poderá ser feita com essa suíte de \textit{scripts} será relacionada aos percentis das métricas.
Dada uma amostra (ou coleção de dados), os percentis são medidas que dividem a amostra ordenada (por ordem crescente dos dados) 
em cem (100) partes, cada uma com uma percentagem de dados aproximadamente igual. Define-se percentil k, ${Q_k}$, 
k recebendo valores de um (1) a noventa e nove (99), como sendo o valor tal que k\% dos elementos da amostra são menores ou 
iguais a ${Q_k}$ e os restantes (100-k)\% elementos da amostra são maiores ou iguais a ${Q_k}$ \cite{martins2013}. Os valores
de percentis utilizados são: 

\begin{multicols}{3}
  \begin{itemize}
    \item 1\%
    \item 5\%
    \item 10\%
    \item 25\%
    \item 50\%
    \item 75\%
    \item 90\%
    \item 95\%
    \item 99\%
  \end{itemize}
\end{multicols}

A saída desse processo de análise estatística serão gráficos dos percentis e um arquivo texto com a quantidade de valores 
dentro de cada intervalo de percentil.

Tendo os percentis das métricas será possível fazer uma análise, sabendo em quais faixas geralmente ocorre 
determinados tipos de vulnerabilidades e tentar definir em qual faixa é aceitável ou não os valores das métricas de 
vulnerabilidade de código fonte.

Foram desenvolvidos para este trabalho \textit{scripts}\footnote{Disponível em
\url{https://github.com/lucaskanashiro/clang\_parser\_html\_to\_csv}} para a adequação dos
dados advindos da ferramenta de extração de métricas de vulnerabilidade de
código fonte (\emph{Clang}, apresentado na subseção \ref{clang}). A saída padrão
da ferramenta é um arquivo HTML e a suíte de \textit{scripts} apresentados
anteriormente tem como um dos requisitos o arquivo de entrada ser do formato
CSV. Esses \textit{scripts} de adequação do formato dos dados utiliza-se de
expressões regulares para encontrar padrões e contar as ocorrências de
determinada cenário de vulnerabilidade, e com isso esses valores são escritos em
um arquivo CSV.

\subsection{Teste das Hipóteses} \label{subsec:teste_hipotese}

Nesta seção será feito o teste das hipóteses apresentadas na subseção
\ref{subsec:hipoteses}, utilizando as ferramentas apresentadas em \ref{subsec:ferramentas}.

\subsubsection{Coleta de Dados}

Para realizar a coleta dos dados para iniciar o teste dos hipóteses, foram
realizadas as seguintes atividades do processo descrito pelo fluxograma
\ref{fig:processo_estudo_de_caso}:

\begin{itemize}
  \item Selecionar projeto
  \item Obter código fonte
  \item Identificar como construir projeto
  \item Extrair métricas de vulnerabilidade
\end{itemize}

Para o teste dessa hipótese foi selecionado um projeto de software considerado
representativo no contexto de vulnerabilidades de código fonte, que é o projeto
\emph{Linux Kernel}. Ele é a base para a grande maioria dos sistemas operacionais
disponíveis, esses sistemas são bastante utilizados por Engenheiros de Software para
o próprio desenvolvimento de software, além de ser o sistema operacional em
execução na grande maioria dos servidores de aplicações, onde geralmente
atacantes exploram vulnerabilidades ao utilizarem-se de \textit{exploits}, como
foi apresentado na seção \ref{cap:metricas_vuln}.

O código fonte do projeto \emph{Linux Kernel} foi obtido no repositório \footnote{Disponível em:
\url{git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git}} do seu
criador Linus Torvalds. Para encontrar o repositório foi utilizado a ferramenta
\emph{OpenHub} \footnote{Acessível em: \url{https://www.openhub.net/}}, onde
pode-se encontrar várias informações dessa natureza.

Para a construição (\textit{build}) do projeto existe documentação em diversos
locais, praticamente todas as distribuições \emph{Linux} possuem essa
documentação. Para este estudo de caso foi utilizada a documentação de uma das
distribuições \emph{Linux} mais conhecidas, do Ubuntu \footnote{Documentação para
  contrução do \emph{Linux Kernel}:
\url{https://help.ubuntu.com/community/Kernel/Compile}}.

Para a extração dos valores das métricas de vulnerabilidade de código fonte foi
utilizada a ferramenta \emph{Clang}, descrita na subseção
\ref{clang}. Foi utilizado a biblioteca de aplicativo
\textit{Analysis}, como apresentado na subseção já mencionada, mais conhecido como \emph{Clang Static
Analyzer}. Foi utilizado a documentação do próprio \emph{Clang Static Analyzer}
\footnote{Acessível em: \url{http://clang-analyzer.llvm.org/scan-build.html}},
entretanto, só é necessário adicionar uma chamada para a aplicação
(\textit{scan-build}) antes da linha de comando de construção do projeto.

Após a execução do \emph{Clang Static Analyzer} juntamente com a construção do
projeto, é dado um arquivo HTML como saída da aplicação. Como foi explicado na
subseção \ref{scripts}, esse não é o formato esperado pela suíte de
\textit{scripts} utilizados para análise estatística, com isso, foi feita a
adequação desses dados de maneira automatizada, como explicado no final da
subseção \ref{scripts}. Ao final, um arquivo CSV foi gerado com as métricas de
vulnerabilidade de código fonte por módulo do \emph{Linux Kernel}.

\subsubsection{Análise dos Resultados}

Tendo o arquivo CSV com a valoração das métricas de vulnerabilidade de código
fonte do projeto \emph{Linux Kernel}, houve a necessidade de uma reflexão antes
de prosseguir com o processo apresentado. Ao
fazer uma análise inicial dos valores das métricas, viu-se que grande parte
possuía valoração nula (igual a zero), representando que na maioria dos módulos
do \emph{Linux Kernel} não possuía vulnerabilidades de código fonte. Das vinte
métricas de vulnerabilidade de código fonte apresentadas na seção
\ref{cap:metricas_vuln}, apenas duas delas possuíram valoração não nula, sendo
elas DNP e DUPV. 

Com isso, antes de se concluir o estudo de caso, já foi
possível negar a hipótese \emph{H1} e \emph{H2} apresentadas na subseção
\ref{subsec:hipoteses}, pois a forma de observar as métricas de vulnerabilidade
é diferente da de \textit{design} de código fonte, além de a média dos valores
das métricas dos módulos não ser relevante para o seu acompanhamento. Métricas de \textit{design},
em geral, não possui essa grande quantidade de valoração nula das métricas nos
módulos de um grande projeto como o \emph{Linux Kernel}, diferente do que
pode-se observar com as métricas de vulnerabilidade de código fonte. E como
grande parte dos módulos possuí valoração das métricas nulas, a média desses
valores não é representativo para o acompanhamento das mesmas.

Após essa constatação, continuou-se o processo apresentado no fluxograma 
\ref{fig:processo_estudo_de_caso}, foram realizadas as seguintes atividades:

\begin{itemize}
  \item Realizar análise estatística
  \item Analisar resultados
  \item Realizar conclusões
\end{itemize}

Antes de iniciar a atividade de análise estatística decidiu-se não testar a
hipótese \emph{H3} referente as distribuições estatísticas, pois, devido a
hipótese \emph{H1} ter sido negada, preferiu-se realizar uma análise qualitativa
antes para tentar entender como que deve-se observar métricas de vulnerabilidade de código
fonte antes de tentar encontrar distribuições estatísticas que represente-as.
Talvez, a distribuição estatística não seja relevante para acompanha-las, por
isso essa hipótese não foi testada neste estudo de caso.

Apesar de todas as hipóteses terem se esgotado nesse ponto do estudo de caso,
foi preferível a continuação do estudo para tentar extrair alguma informação
útil para a questão do acompanhamento de métricas de vulnerabilidade de código
fonte.

Na atividade de realizar a análise estatística foi utilizada a suíte de
\textit{scripts} apresentados na subseção \ref{scripts}, entretanto, só foi
trabalhado com os percentis dos valores das métricas, a fim de tentar extrair
alguma informação relevante. Os gráficos dos percentis de cada uma das métricas 
de vulnerabilidade trabalhadas pode ser encontrado no anexo \ref{anex:percentis}.

Analisando os resultados através dos gráficos gerados pode-se ver que a maioria das métricas se manteve
em zero em todos os módulos do \emph{Linux Kernel}, tendo variado apenas os
valores das métricas DNP (\ref{graphic:dnp}) e DUPV (\ref{graphic:dupv}). Levando 
em consideração apenas os gráficos das métricas não nulas, pode-se ver que os valores 
das métricas se concentram nos percentis mais elevados, com isso, conclui-se que
a grande maioria dos valores dessas métricas possuem valores similares na
maioria dos módulos, não variando muito a sua valoração. Entretanto, essa
informação não agrega tanto valor no que diz respeito a como se acompanhar
métricas de vulnerabilidade de código fonte em um projeto de software, apenas nos mostra que a
maioria dos valores das métricas são similares, ou seja, se o valor de uma
métrica variar muito de um módulo para outro, existe um indício de que algo pode
estar errado.

Ao realizar a análise apresentada acima, chegou-se a conclusão que para entender
melhor as métricas de vulnerabilidade de código fonte é necessário realizar uma
análise qualitativa ao invés de quantitativa. Com isso, resolveu-se realizar uma
nova análise, agora qualitativa, das métricas de vulnerabilidade de código fonte
extraídas do projeto \emph{Linux Kernel}, para tentar compreender um pouco
melhor a natureza dessas métricas, essa análise é apresentada na seção
\ref{sec:analise_qualitativa}.

\section{Análise Qualitativa} \label{sec:analise_qualitativa}

